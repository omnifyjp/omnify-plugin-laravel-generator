---
paths:
  - "{{LARAVEL_ROOT}}app/**/*.php"
---

# Performance & Quality Rules

> **Non-negotiable rules** for Laravel performance and code quality.

## ðŸŸ  N+1 Query Problem

**Always eager load relationships.**

```php
// âŒ N+1 PROBLEM: 1 + N queries (N = number of posts)
$posts = Post::all();
foreach ($posts as $post) {
    echo $post->author->name;  // Query for each post!
}

// âœ… CORRECT: Eager loading with with()
$posts = Post::with('author')->get();
foreach ($posts as $post) {
    echo $post->author->name;  // No extra queries
}

// âœ… CORRECT: Multiple relationships
$posts = Post::with(['author', 'comments', 'tags'])->get();

// âœ… CORRECT: Nested eager loading
$posts = Post::with('comments.author')->get();
```

**Enable N+1 detection in development:**

```php
// In AppServiceProvider boot()
use Illuminate\Database\Eloquent\Model;

public function boot(): void
{
    // Throw exception on lazy loading (dev only)
    Model::preventLazyLoading(!app()->isProduction());
}
```

---

## ðŸŸ  Use `whenLoaded()` in Resources

**Prevent queries in Resources.**

```php
// âŒ ERROR: Triggers query if not eager loaded
class PostResource extends JsonResource
{
    public function toArray($request): array
    {
        return [
            'author' => new UserResource($this->author),  // N+1!
        ];
    }
}

// âœ… CORRECT: Only include if already loaded
class PostResource extends JsonResource
{
    public function toArray($request): array
    {
        return [
            'author' => new UserResource($this->whenLoaded('author')),
        ];
    }
}
```

---

## ðŸŸ  Pagination for List Endpoints

**Never return all records.**

```php
// âŒ ERROR: Returns all records (memory + performance)
public function index()
{
    return UserResource::collection(User::all());  // 1M users = crash
}

// âœ… CORRECT: Always paginate
public function index(Request $request)
{
    $perPage = min($request->input('per_page', 15), 100);  // Max 100
    return UserResource::collection(User::paginate($perPage));
}
```

---

## ðŸŸ  Select Only Needed Columns

**Don't SELECT * when you need few fields.**

```php
// âŒ INEFFICIENT: Fetches all columns
$users = User::all();
$names = $users->pluck('name');

// âœ… EFFICIENT: Select only needed columns
$names = User::pluck('name');

// âœ… EFFICIENT: For multiple columns
$users = User::select(['id', 'name', 'email'])->get();
```

---

## ðŸŸ¡ Code Quality Rules

### Never Validate in Controller

```php
// âŒ BAD: Validation in controller
public function store(Request $request)
{
    $validated = $request->validate([...]);
}

// âœ… CORRECT: Use FormRequest
public function store(UserStoreRequest $request)
{
    $user = User::create($request->validated());
    return new UserResource($user);
}
```

### Always Use Resource for Responses

```php
// âŒ BAD: Exposes all fields, inconsistent format
return $user;
return response()->json($user);

// âœ… CORRECT: Use Resource
return new UserResource($user);
return UserResource::collection($users);
```

### Use Route Model Binding

```php
// âŒ BAD: Manual find
public function show(int $id)
{
    $user = User::findOrFail($id);
    return new UserResource($user);
}

// âœ… CORRECT: Route model binding
public function show(User $user)
{
    return new UserResource($user);
}
```

### Use Transactions for Multiple Operations

```php
// âŒ BAD: Partial failure possible
$order = Order::create([...]);
$order->items()->createMany([...]);

// âœ… CORRECT: Transaction ensures atomicity
DB::transaction(function () use ($data) {
    $order = Order::create([...]);
    $order->items()->createMany([...]);
    return $order;
});
```

### Never Use env() Outside Config

```php
// âŒ BAD: env() won't work with config:cache
$apiKey = env('API_KEY');

// âœ… CORRECT: Use config()
$apiKey = config('services.api_key');
```

---

## ðŸ”µ Date/Time Rules

### Always Store UTC

```php
// config/app.php
'timezone' => 'UTC',  // NEVER change this

// âŒ BAD: Store local time
$event->scheduled_at = Carbon::now('Asia/Tokyo');

// âœ… CORRECT: Store UTC
$event->scheduled_at = Carbon::now();  // UTC
```

### Always Return ISO 8601 in API

```php
// âŒ BAD: Local format
'created_at' => $this->created_at->format('Y-m-d H:i:s'),

// âœ… CORRECT: ISO 8601 UTC
'created_at' => $this->created_at?->toISOString(),
// Output: "2024-01-15T10:30:00.000000Z"
```

---

## Quick Reference

| Category        | âŒ Never Do                          | âœ… Always Do              |
| --------------- | ----------------------------------- | ------------------------ |
| **Performance** | `Model::all()` without limit        | `Model::paginate()`      |
|                 | Access relation without `with()`    | Eager load with `with()` |
|                 | `$this->relation` in Resource       | `$this->whenLoaded()`    |
| **Quality**     | Validate in Controller              | Use FormRequest          |
|                 | Return Model directly               | Return Resource          |
|                 | `findOrFail($id)`                   | Route model binding      |
|                 | Multiple DB ops without transaction | `DB::transaction()`      |
| **Config**      | `env()` in code                     | `config()`               |
| **Dates**       | Local timezone                      | UTC everywhere           |
|                 | `format('Y-m-d')`                   | `->toISOString()`        |

---

## Development Safeguards

Add to `AppServiceProvider::boot()`:

```php
public function boot(): void
{
    // Prevent N+1 queries (throws exception on lazy load)
    Model::preventLazyLoading(!app()->isProduction());
    
    // Prevent accessing missing attributes
    Model::preventAccessingMissingAttributes(!app()->isProduction());
    
    // Prevent silently discarding attributes
    Model::preventSilentlyDiscardingAttributes(!app()->isProduction());
}
```

These will throw exceptions during development, helping you catch issues early.
