/**
 * @famgia/omnify-laravel - TypeScript Generator
 *
 * Main TypeScript code generator combining interfaces, enums, and types.
 */

import type { SchemaCollection } from '@famgia/omnify-types';
import type { TypeScriptFile, TypeScriptOptions, TSInterface, TSEnum, TSTypeAlias } from './types.js';
import { generateInterfaces, formatInterface } from './interface-generator.js';
import { generateEnums, formatEnum, formatTypeAlias, extractInlineEnums } from './enum-generator.js';

/**
 * Default options for TypeScript generation.
 */
const DEFAULT_OPTIONS: TypeScriptOptions = {
  singleFile: true,
  fileName: 'types.ts',
  readonly: true,
  strictNullChecks: true,
};

/**
 * Generates the file header comment.
 */
function generateHeader(): string {
  return `/**
 * Auto-generated TypeScript types from Omnify schemas.
 * DO NOT EDIT - This file is automatically generated.
 */

`;
}

/**
 * Generates all TypeScript code as a single file.
 */
export function generateTypeScriptFile(
  schemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TypeScriptFile {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const parts: string[] = [generateHeader()];
  const types: string[] = [];

  // Generate enums first (they're referenced by interfaces)
  const enums = generateEnums(schemas);
  if (enums.length > 0) {
    parts.push('// Enums\n');
    for (const enumDef of enums) {
      parts.push(formatEnum(enumDef));
      parts.push('\n\n');
      types.push(enumDef.name);
    }
  }

  // Generate inline enum type aliases
  const inlineEnums = extractInlineEnums(schemas);
  if (inlineEnums.length > 0) {
    parts.push('// Type Aliases\n');
    for (const alias of inlineEnums) {
      parts.push(formatTypeAlias(alias));
      parts.push('\n\n');
      types.push(alias.name);
    }
  }

  // Generate interfaces
  const interfaces = generateInterfaces(schemas, opts);
  if (interfaces.length > 0) {
    parts.push('// Interfaces\n');
    for (const iface of interfaces) {
      parts.push(formatInterface(iface));
      parts.push('\n\n');
      types.push(iface.name);
    }
  }

  return {
    fileName: opts.fileName ?? 'types.ts',
    content: parts.join('').trim() + '\n',
    types,
  };
}

/**
 * Generates TypeScript code as multiple files.
 */
export function generateTypeScriptFiles(
  schemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TypeScriptFile[] {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  const files: TypeScriptFile[] = [];

  // Enums file
  const enums = generateEnums(schemas);
  if (enums.length > 0) {
    const content = generateHeader() +
      enums.map(formatEnum).join('\n\n') + '\n';
    files.push({
      fileName: 'enums.ts',
      content,
      types: enums.map(e => e.name),
    });
  }

  // Inline enums/type aliases file
  const inlineEnums = extractInlineEnums(schemas);
  if (inlineEnums.length > 0) {
    const content = generateHeader() +
      inlineEnums.map(formatTypeAlias).join('\n\n') + '\n';
    files.push({
      fileName: 'type-aliases.ts',
      content,
      types: inlineEnums.map(a => a.name),
    });
  }

  // Individual interface files
  const interfaces = generateInterfaces(schemas, opts);
  for (const iface of interfaces) {
    const imports = collectImports(iface, enums, inlineEnums, interfaces);
    const importStatement = formatImports(imports);

    const content = generateHeader() +
      (importStatement ? importStatement + '\n\n' : '') +
      formatInterface(iface) + '\n';

    files.push({
      fileName: `${toKebabCase(iface.name)}.ts`,
      content,
      types: [iface.name],
    });
  }

  // Index file
  const indexContent = generateIndexFile(files);
  files.push({
    fileName: 'index.ts',
    content: indexContent,
    types: [],
  });

  return files;
}

/**
 * Converts PascalCase to kebab-case.
 */
function toKebabCase(name: string): string {
  return name
    .replace(/([A-Z])/g, '-$1')
    .toLowerCase()
    .replace(/^-/, '');
}

/**
 * Collects imports needed for an interface.
 */
function collectImports(
  iface: TSInterface,
  enums: TSEnum[],
  typeAliases: TSTypeAlias[],
  allInterfaces: TSInterface[]
): Map<string, string[]> {
  const imports = new Map<string, string[]>();
  const enumNames = new Set(enums.map(e => e.name));
  const aliasNames = new Set(typeAliases.map(a => a.name));
  const interfaceNames = new Set(allInterfaces.map(i => i.name));

  for (const prop of iface.properties) {
    // Check if type references an enum
    if (enumNames.has(prop.type)) {
      const existing = imports.get('./enums.js') ?? [];
      if (!existing.includes(prop.type)) {
        imports.set('./enums.js', [...existing, prop.type]);
      }
    }

    // Check if type references a type alias
    if (aliasNames.has(prop.type)) {
      const existing = imports.get('./type-aliases.js') ?? [];
      if (!existing.includes(prop.type)) {
        imports.set('./type-aliases.js', [...existing, prop.type]);
      }
    }

    // Check if type references another interface (for relationships)
    const baseType = prop.type.replace('[]', '');
    if (interfaceNames.has(baseType) && baseType !== iface.name) {
      const fileName = `./${toKebabCase(baseType)}.js`;
      const existing = imports.get(fileName) ?? [];
      if (!existing.includes(baseType)) {
        imports.set(fileName, [...existing, baseType]);
      }
    }
  }

  return imports;
}

/**
 * Formats import statements.
 */
function formatImports(imports: Map<string, string[]>): string {
  if (imports.size === 0) return '';

  const lines: string[] = [];
  for (const [path, names] of imports) {
    lines.push(`import type { ${names.join(', ')} } from '${path}';`);
  }
  return lines.join('\n');
}

/**
 * Generates index.ts file for re-exports.
 */
function generateIndexFile(files: TypeScriptFile[]): string {
  const exports: string[] = [generateHeader().trim(), ''];

  for (const file of files) {
    if (file.fileName === 'index.ts') continue;
    const moduleName = file.fileName.replace('.ts', '.js');
    exports.push(`export * from './${moduleName}';`);
  }

  return exports.join('\n') + '\n';
}

/**
 * Generates TypeScript types with configurable output.
 */
export function generateTypeScript(
  schemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TypeScriptFile[] {
  const opts = { ...DEFAULT_OPTIONS, ...options };

  if (opts.singleFile) {
    return [generateTypeScriptFile(schemas, opts)];
  }

  return generateTypeScriptFiles(schemas, opts);
}

/**
 * Gets output path for a TypeScript file.
 */
export function getTypeScriptPath(
  file: TypeScriptFile,
  outputDir: string = 'src/types'
): string {
  return `${outputDir}/${file.fileName}`;
}
