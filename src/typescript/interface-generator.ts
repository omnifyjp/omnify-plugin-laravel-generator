/**
 * @famgia/omnify-laravel - TypeScript Interface Generator
 *
 * Generates TypeScript interfaces from schemas.
 */

import type { LoadedSchema, PropertyDefinition, SchemaCollection, InlineEnumValue } from '@famgia/omnify-types';
import { resolveLocalizedString } from '@famgia/omnify-types';
import type { TSInterface, TSProperty, TypeScriptOptions } from './types.js';
import { getEnumStringValues } from '../utils.js';

/**
 * Maps Omnify property types to TypeScript types.
 */
const TYPE_MAP: Record<string, string> = {
  String: 'string',
  Int: 'number',
  BigInt: 'number',
  Float: 'number',
  Boolean: 'boolean',
  Text: 'string',
  LongText: 'string',
  Date: 'string',
  Time: 'string',
  Timestamp: 'string',
  Json: 'unknown',
  Email: 'string',
  Password: 'string',
  Enum: 'string',
  Select: 'string',
  Lookup: 'number',
};

/**
 * File interface name (references the File.yaml schema).
 * The File schema is auto-generated by ensureFileSchema() when File type is used.
 */
export const FILE_INTERFACE_NAME = 'File';

/**
 * Maps primary key types to TypeScript types.
 */
const PK_TYPE_MAP: Record<string, string> = {
  Int: 'number',
  BigInt: 'number',
  Uuid: 'string',
  String: 'string',
};

/**
 * Converts property name to TypeScript property name.
 * Preserves camelCase.
 */
export function toPropertyName(name: string): string {
  return name;
}

/**
 * Converts schema name to TypeScript interface name.
 * Preserves PascalCase.
 */
export function toInterfaceName(schemaName: string): string {
  return schemaName;
}

/**
 * Gets TypeScript type for a property.
 */
export function getPropertyType(
  property: PropertyDefinition,
  _allSchemas: SchemaCollection
): string {
  // Handle File type specially (polymorphic relation to files table)
  // References the File interface generated from File.yaml schema
  if (property.type === 'File') {
    const fileProp = property as { multiple?: boolean };
    if (fileProp.multiple) {
      return `${FILE_INTERFACE_NAME}[]`;
    }
    return `${FILE_INTERFACE_NAME} | null`;
  }

  // Handle associations
  if (property.type === 'Association') {
    const assocProp = property as {
      relation?: string;
      target?: string;
      targets?: readonly string[];
    };

    const targetName = assocProp.target ?? 'unknown';

    switch (assocProp.relation) {
      // Standard relations
      case 'OneToOne':
      case 'ManyToOne':
        return targetName;
      case 'OneToMany':
      case 'ManyToMany':
        return `${targetName}[]`;

      // Polymorphic relations
      case 'MorphTo':
        // Union type of all possible targets
        if (assocProp.targets && assocProp.targets.length > 0) {
          return assocProp.targets.join(' | ');
        }
        return 'unknown';
      case 'MorphOne':
        return targetName;
      case 'MorphMany':
      case 'MorphToMany':
      case 'MorphedByMany':
        return `${targetName}[]`;

      default:
        return 'unknown';
    }
  }

  // Handle enum types
  if (property.type === 'Enum') {
    const enumProp = property as { enum?: string | readonly (string | InlineEnumValue)[] };
    if (typeof enumProp.enum === 'string') {
      // Reference to a named enum
      return enumProp.enum;
    }
    if (Array.isArray(enumProp.enum)) {
      // Inline enum - create union type (handles both string[] and InlineEnumValue[])
      const enumValues = getEnumStringValues(enumProp.enum);
      return enumValues.map(v => `'${v}'`).join(' | ');
    }
  }

  // Handle Select with options
  if (property.type === 'Select') {
    const selectProp = property as { options?: readonly string[] };
    if (selectProp.options && selectProp.options.length > 0) {
      return selectProp.options.map(v => `'${v}'`).join(' | ');
    }
  }

  // Standard type mapping
  return TYPE_MAP[property.type] ?? 'unknown';
}

/**
 * Converts a property to TypeScript property definition.
 * For MorphTo, returns multiple properties (_type, _id, and relation).
 */
export function propertyToTSProperties(
  propertyName: string,
  property: PropertyDefinition,
  allSchemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TSProperty[] {
  const baseProp = property as { nullable?: boolean; displayName?: string };
  const isReadonly = options.readonly ?? true;

  // Handle MorphTo specially - it creates _type and _id columns
  if (property.type === 'Association') {
    const assocProp = property as {
      relation?: string;
      targets?: readonly string[];
    };

    if (assocProp.relation === 'MorphTo' && assocProp.targets && assocProp.targets.length > 0) {
      const propBaseName = toPropertyName(propertyName);
      const targetUnion = assocProp.targets.map(t => `'${t}'`).join(' | ');
      const relationUnion = assocProp.targets.join(' | ');

      return [
        {
          name: `${propBaseName}Type`,
          type: targetUnion,
          optional: true, // Polymorphic columns are nullable
          readonly: isReadonly,
          comment: `Polymorphic type for ${propertyName}`,
        },
        {
          name: `${propBaseName}Id`,
          type: 'number',
          optional: true,
          readonly: isReadonly,
          comment: `Polymorphic ID for ${propertyName}`,
        },
        {
          name: propBaseName,
          type: `${relationUnion} | null`,
          optional: true,
          readonly: isReadonly,
          comment: baseProp.displayName ?? `Polymorphic relation to ${assocProp.targets.join(', ')}`,
        },
      ];
    }
  }

  // Default: single property
  const type = getPropertyType(property, allSchemas);

  return [{
    name: toPropertyName(propertyName),
    type,
    optional: baseProp.nullable ?? false,
    readonly: isReadonly,
    comment: baseProp.displayName,
  }];
}

/**
 * Converts a property to TypeScript property definition (legacy - returns single property).
 */
export function propertyToTSProperty(
  propertyName: string,
  property: PropertyDefinition,
  allSchemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TSProperty {
  return propertyToTSProperties(propertyName, property, allSchemas, options)[0]!;
}

/**
 * Generates TypeScript interface from schema.
 */
export function schemaToInterface(
  schema: LoadedSchema,
  allSchemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TSInterface {
  const properties: TSProperty[] = [];

  // ID property (only if id is not disabled)
  if (schema.options?.id !== false) {
    const pkType = (schema.options?.idType ?? 'BigInt') as keyof typeof PK_TYPE_MAP;
    properties.push({
      name: 'id',
      type: PK_TYPE_MAP[pkType] ?? 'number',
      optional: false,
      readonly: options.readonly ?? true,
      comment: 'Primary key',
    });
  }

  // Schema properties
  if (schema.properties) {
    for (const [propName, property] of Object.entries(schema.properties)) {
      // Use propertyToTSProperties which handles MorphTo returning multiple properties
      properties.push(...propertyToTSProperties(propName, property, allSchemas, options));
    }
  }

  // Timestamps
  if (schema.options?.timestamps !== false) {
    properties.push(
      {
        name: 'createdAt',
        type: 'string',
        optional: true,
        readonly: options.readonly ?? true,
        comment: 'Creation timestamp',
      },
      {
        name: 'updatedAt',
        type: 'string',
        optional: true,
        readonly: options.readonly ?? true,
        comment: 'Last update timestamp',
      }
    );
  }

  // Soft delete
  if (schema.options?.softDelete) {
    properties.push({
      name: 'deletedAt',
      type: 'string',
      optional: true,
      readonly: options.readonly ?? true,
      comment: 'Soft delete timestamp',
    });
  }

  return {
    name: toInterfaceName(schema.name),
    properties,
    comment: resolveLocalizedString(schema.displayName) ?? schema.name,
  };
}

/**
 * Formats a TypeScript property.
 */
export function formatProperty(property: TSProperty): string {
  const readonly = property.readonly ? 'readonly ' : '';
  const optional = property.optional ? '?' : '';
  const comment = property.comment ? `  /** ${property.comment} */\n` : '';
  return `${comment}  ${readonly}${property.name}${optional}: ${property.type};`;
}

/**
 * Formats a TypeScript interface.
 */
export function formatInterface(iface: TSInterface): string {
  const comment = iface.comment ? `/**\n * ${iface.comment}\n */\n` : '';
  const extendsClause = iface.extends && iface.extends.length > 0
    ? ` extends ${iface.extends.join(', ')}`
    : '';
  const properties = iface.properties.map(formatProperty).join('\n');

  return `${comment}export interface ${iface.name}${extendsClause} {\n${properties}\n}`;
}

/**
 * Generates interfaces for all schemas.
 * Note: File interface is now generated from File.yaml schema (use ensureFileSchema() to auto-create it).
 */
export function generateInterfaces(
  schemas: SchemaCollection,
  options: TypeScriptOptions = {}
): TSInterface[] {
  const interfaces: TSInterface[] = [];

  for (const schema of Object.values(schemas)) {
    // Skip enum schemas
    if (schema.kind === 'enum') {
      continue;
    }

    interfaces.push(schemaToInterface(schema, schemas, options));
  }

  return interfaces;
}
