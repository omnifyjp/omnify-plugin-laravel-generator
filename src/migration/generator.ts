/**
 * @famgia/omnify-laravel - Migration Generator
 *
 * Generates Laravel migration files from schemas.
 */

import type { LoadedSchema, SchemaCollection } from '@famgia/omnify-types';
import type {
  MigrationFile,
  MigrationOptions,
  TableBlueprint,
} from './types.js';
import {
  schemaToBlueprint,
  formatColumnMethod,
  formatForeignKey,
  formatIndex,
  extractManyToManyRelations,
  generatePivotTableBlueprint,
  toTableName,
} from './schema-builder.js';

/**
 * Generates timestamp prefix for migration file name.
 */
function generateTimestamp(): string {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');
  return `${year}_${month}_${day}_${hours}${minutes}${seconds}`;
}

/**
 * Converts table name to Laravel migration class name.
 */
function toClassName(tableName: string, type: 'create' | 'alter' | 'drop'): string {
  const pascalCase = tableName
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('');

  switch (type) {
    case 'create':
      return `Create${pascalCase}Table`;
    case 'alter':
      return `Alter${pascalCase}Table`;
    case 'drop':
      return `Drop${pascalCase}Table`;
  }
}

/**
 * Generates file name for migration.
 */
function generateFileName(
  tableName: string,
  type: 'create' | 'alter' | 'drop',
  timestamp?: string
): string {
  const ts = timestamp ?? generateTimestamp();
  const action = type === 'create' ? 'create' : type === 'drop' ? 'drop' : 'update';
  return `${ts}_${action}_${tableName}_table.php`;
}

/**
 * Renders the up method body for a create table operation.
 */
function renderCreateTableUp(blueprint: TableBlueprint): string {
  const lines: string[] = [];

  // Column definitions
  for (const column of blueprint.columns) {
    lines.push(`            ${formatColumnMethod(column)}`);
  }

  // Foreign keys (separate for Laravel best practices)
  // Note: Foreign keys should be in a separate migration or at the end
  // We'll include them in the same migration for simplicity

  return lines.join('\n');
}

/**
 * Renders foreign key constraints (usually added after all columns).
 */
function renderForeignKeys(blueprint: TableBlueprint): string {
  if (blueprint.foreignKeys.length === 0) {
    return '';
  }

  const lines = blueprint.foreignKeys.map(fk => `            ${formatForeignKey(fk)}`);
  return '\n' + lines.join('\n');
}

/**
 * Renders indexes.
 */
function renderIndexes(blueprint: TableBlueprint): string {
  // Filter out indexes that are already handled (primary key, unique columns)
  const customIndexes = blueprint.indexes.filter(idx => {
    // Skip single-column unique indexes (handled by column modifier)
    if (idx.unique && idx.columns.length === 1) {
      return false;
    }
    return true;
  });

  if (customIndexes.length === 0) {
    return '';
  }

  const lines = customIndexes.map(idx => `            ${formatIndex(idx)}`);
  return '\n' + lines.join('\n');
}

/**
 * Renders composite primary key (for tables with id: false and multiple primary columns).
 */
function renderCompositePrimaryKey(blueprint: TableBlueprint): string {
  // 複合主キーの場合のみレンダリング
  // 単一カラムの主キーはカラム定義で処理される（$table->id() など）
  if (!blueprint.primaryKey || blueprint.primaryKey.length <= 1) {
    return '';
  }

  const columnsStr = blueprint.primaryKey.map(c => `'${c}'`).join(', ');
  return `\n            $table->primary([${columnsStr}]);`;
}

/**
 * Generates a create table migration.
 */
function generateCreateMigration(
  blueprint: TableBlueprint,
  options: MigrationOptions = {}
): MigrationFile {
  const className = toClassName(blueprint.tableName, 'create');
  const fileName = generateFileName(blueprint.tableName, 'create', options.timestamp);

  const connection = options.connection
    ? `\n    protected $connection = '${options.connection}';\n`
    : '';

  const upContent = renderCreateTableUp(blueprint);
  const foreignKeyContent = renderForeignKeys(blueprint);
  const indexContent = renderIndexes(blueprint);
  const primaryKeyContent = renderCompositePrimaryKey(blueprint);

  const content = `<?php

/**
 * ⚠️ DO NOT EDIT THIS FILE! ⚠️
 * このファイルを編集しないでください！
 * KHÔNG ĐƯỢC SỬA FILE NÀY!
 *
 * This file is AUTO-GENERATED by Omnify.
 * Any manual changes will be OVERWRITTEN on next generation.
 *
 * To modify: Edit the schema YAML file and run: npx omnify generate
 *
 * @generated by @famgia/omnify-laravel
 */

use Illuminate\\Database\\Migrations\\Migration;
use Illuminate\\Database\\Schema\\Blueprint;
use Illuminate\\Support\\Facades\\Schema;

return new class extends Migration
{${connection}
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('${blueprint.tableName}', function (Blueprint $table) {
${upContent}${foreignKeyContent}${indexContent}${primaryKeyContent}
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('${blueprint.tableName}');
    }
};
`;

  return {
    fileName,
    className,
    content,
    tables: [blueprint.tableName],
    type: 'create',
  };
}

/**
 * Generates a drop table migration.
 */
function generateDropMigration(
  tableName: string,
  options: MigrationOptions = {}
): MigrationFile {
  const className = toClassName(tableName, 'drop');
  const fileName = generateFileName(tableName, 'drop', options.timestamp);

  const connection = options.connection
    ? `\n    protected $connection = '${options.connection}';\n`
    : '';

  const content = `<?php

/**
 * ⚠️ DO NOT EDIT THIS FILE! ⚠️
 * このファイルを編集しないでください！
 * KHÔNG ĐƯỢC SỬA FILE NÀY!
 *
 * This file is AUTO-GENERATED by Omnify.
 * Any manual changes will be OVERWRITTEN on next generation.
 *
 * @generated by @famgia/omnify-laravel
 */

use Illuminate\\Database\\Migrations\\Migration;
use Illuminate\\Database\\Schema\\Blueprint;
use Illuminate\\Support\\Facades\\Schema;

return new class extends Migration
{${connection}
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::dropIfExists('${tableName}');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Cannot recreate table without schema information
        // This is a one-way migration
    }
};
`;

  return {
    fileName,
    className,
    content,
    tables: [tableName],
    type: 'drop',
  };
}

/**
 * Extracts FK dependencies from a schema.
 * Returns array of schema names that this schema depends on.
 */
function extractDependencies(schema: LoadedSchema): string[] {
  const deps: string[] = [];

  // Pivot schemas depend on all tables in pivotFor
  // pivotFor: [Post, Tag] → depends on both Post and Tag
  if (schema.kind === 'pivot' && schema.pivotFor) {
    deps.push(...schema.pivotFor);
  }

  if (!schema.properties) {
    return deps;
  }

  for (const property of Object.values(schema.properties)) {
    if (property.type !== 'Association') {
      continue;
    }

    const assocProp = property as {
      relation?: string;
      target?: string;
      mappedBy?: string;
    };

    // ManyToOne and OneToOne (owning side) create FK columns
    if (
      (assocProp.relation === 'ManyToOne' || assocProp.relation === 'OneToOne') &&
      !assocProp.mappedBy &&
      assocProp.target
    ) {
      deps.push(assocProp.target);
    }
  }

  return deps;
}

/**
 * Topological sort of schemas based on FK dependencies.
 * Returns schemas in order where dependencies come before dependents.
 */
function topologicalSort(schemas: SchemaCollection): LoadedSchema[] {
  const schemaList = Object.values(schemas).filter(s => s.kind !== 'enum');
  const sorted: LoadedSchema[] = [];
  const visited = new Set<string>();
  const visiting = new Set<string>(); // For cycle detection

  function visit(schema: LoadedSchema): void {
    if (visited.has(schema.name)) {
      return;
    }

    if (visiting.has(schema.name)) {
      // Circular dependency - just continue (FK can be nullable)
      return;
    }

    visiting.add(schema.name);

    // Visit dependencies first
    const deps = extractDependencies(schema);
    for (const depName of deps) {
      const depSchema = schemas[depName];
      if (depSchema && depSchema.kind !== 'enum') {
        visit(depSchema);
      }
    }

    visiting.delete(schema.name);
    visited.add(schema.name);
    sorted.push(schema);
  }

  // Visit all schemas
  for (const schema of schemaList) {
    visit(schema);
  }

  return sorted;
}

/**
 * Generates migrations for all schemas.
 */
export function generateMigrations(
  schemas: SchemaCollection,
  options: MigrationOptions = {}
): MigrationFile[] {
  const migrations: MigrationFile[] = [];
  const pivotTablesGenerated = new Set<string>();
  let timestampOffset = 0;

  // Note: File table (for polymorphic file storage) is now managed as a proper schema (File.yaml)
  // It will be processed like any other schema in the topological sort below.
  // Use ensureFileSchema() from @famgia/omnify-core to auto-generate File.yaml when needed.

  // Sort schemas by FK dependencies (topological sort)
  const sortedSchemas = topologicalSort(schemas);

  // Generate base timestamp ONCE for all migrations to ensure consistent ordering
  // This prevents timestamp drift when generateTimestamp() was called inside loops
  const baseTimestamp = options.timestamp ?? generateTimestamp();

  // Generate main table migrations in dependency order
  for (const schema of sortedSchemas) {
    // Generate timestamp with offset to ensure unique filenames
    const offsetTimestamp = incrementTimestamp(baseTimestamp, timestampOffset);
    timestampOffset++;

    const blueprint = schemaToBlueprint(schema, schemas, {
      customTypes: options.customTypes,
      pluginEnums: options.pluginEnums,
      locale: options.locale,
    });
    const migration = generateCreateMigration(blueprint, {
      ...options,
      timestamp: offsetTimestamp,
    });
    // スキーマ名を追加（パッケージ出力ルーティング用）
    migrations.push({
      ...migration,
      schemaName: schema.name,
    });
  }

  // 明示的に定義されたピボットテーブルのスキーマ名を収集
  // （ManyToMany自動生成をスキップするため）
  const explicitPivotTableNames = new Set<string>();
  for (const schema of sortedSchemas) {
    const schemaTableName = schema.options?.tableName ?? toTableName(schema.name);
    explicitPivotTableNames.add(schemaTableName);
  }

  // Third pass: generate pivot table migrations for ManyToMany (always last)
  for (const schema of sortedSchemas) {
    const pivotTables = extractManyToManyRelations(schema, schemas);

    for (const pivot of pivotTables) {
      // Skip if already generated
      if (pivotTablesGenerated.has(pivot.tableName)) {
        continue;
      }

      // 明示的なスキーマが存在する場合はスキップ
      // （例：RolePermission.yaml が role_permissions テーブルを定義している場合）
      if (explicitPivotTableNames.has(pivot.tableName)) {
        pivotTablesGenerated.add(pivot.tableName);
        continue;
      }

      pivotTablesGenerated.add(pivot.tableName);

      const offsetTimestamp = incrementTimestamp(baseTimestamp, timestampOffset);
      timestampOffset++;

      const blueprint = generatePivotTableBlueprint(pivot);
      const migration = generateCreateMigration(blueprint, {
        ...options,
        timestamp: offsetTimestamp,
      });
      migrations.push(migration);
    }
  }

  return migrations;
}

/**
 * Increments a timestamp by seconds.
 */
function incrementTimestamp(timestamp: string, seconds: number): string {
  if (seconds === 0) return timestamp;

  // Parse timestamp: YYYY_MM_DD_HHMMSS
  const parts = timestamp.split('_');
  if (parts.length < 4) {
    // Invalid format, return original
    return timestamp;
  }

  const yearPart = parts[0] ?? '2024';
  const monthPart = parts[1] ?? '01';
  const dayPart = parts[2] ?? '01';
  const timePart = parts[3] ?? '000000';

  const year = parseInt(yearPart, 10);
  const month = parseInt(monthPart, 10) - 1;
  const day = parseInt(dayPart, 10);
  const hours = parseInt(timePart.substring(0, 2), 10);
  const minutes = parseInt(timePart.substring(2, 4), 10);
  const secs = parseInt(timePart.substring(4, 6), 10);

  const date = new Date(year, month, day, hours, minutes, secs + seconds);

  const newYear = date.getFullYear();
  const newMonth = String(date.getMonth() + 1).padStart(2, '0');
  const newDay = String(date.getDate()).padStart(2, '0');
  const newHours = String(date.getHours()).padStart(2, '0');
  const newMinutes = String(date.getMinutes()).padStart(2, '0');
  const newSecs = String(date.getSeconds()).padStart(2, '0');

  return `${newYear}_${newMonth}_${newDay}_${newHours}${newMinutes}${newSecs}`;
}

/**
 * Generates migration from a single schema.
 */
export function generateMigrationFromSchema(
  schema: LoadedSchema,
  allSchemas: SchemaCollection,
  options: MigrationOptions = {}
): MigrationFile {
  const blueprint = schemaToBlueprint(schema, allSchemas);
  return generateCreateMigration(blueprint, options);
}

/**
 * Generates drop migration for a table.
 */
export function generateDropMigrationForTable(
  tableName: string,
  options: MigrationOptions = {}
): MigrationFile {
  return generateDropMigration(tableName, options);
}

/**
 * Formats migration content for writing to file.
 */
export function formatMigrationFile(migration: MigrationFile): string {
  return migration.content;
}

/**
 * Gets the output path for a migration file.
 */
export function getMigrationPath(
  migration: MigrationFile,
  outputDir: string = 'database/migrations'
): string {
  return `${outputDir}/${migration.fileName}`;
}
